    // Main initialization when document is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the application state
    const appState = {
        currentScreen: 'welcome',
        scanConfig: {
            targetIP: '192.168.1.0/24',
            targetHostname: '',
            excludeIPs: '',
            scanType: 'Full Vulnerability Scan',
            scanIntensity: 'Medium (Balanced approach)',
            portRange: 'Standard Ports (1-1024)',
            authenticated: true,
            authType: 'Windows (SMB)',
            username: 'scanner_user',
            password: '************',
            categories: ['Operating System', 'Network Services', 'Web Applications', 'Databases', 'Misconfigurations'],
            schedule: 'Run Immediately'
        },
        scanProgress: {
            status: 'not_started', // not_started, running, paused, completed
            progress: 0,
            hostsScanned: 0,
            totalHosts: 165,
            vulnerabilities: [],
            logs: []
        },
        vulnerabilities: [
            {
                id: 'MS17-010',
                name: 'EternalBlue SMBv1 Vulnerability',
                host: '192.168.1.24',
                severity: 'critical',
                category: 'Network Services',
                status: 'open',
                description: 'The SMBv1 protocol in Microsoft Windows contains a remote code execution vulnerability.',
                details: {
                    cve: 'CVE-2017-0144',
                    discovered: 'May 1, 2025',
                    affected: 'Windows Server 2008 R2 with SMBv1 protocol enabled',
                    evidence: 'Confirmed via smb-vuln-ms17-010 Nmap script',
                    impact: ['Remote code execution', 'Full system compromise', 'Lateral movement', 'Ransomware deployment'],
                    remediation: [
                        'Apply Security Patch MS17-010',
                        'Disable SMBv1 protocol',
                        'Block SMB Ports at the firewall',
                        'Implement network segmentation',
                        'Apply Group Policy changes'
                    ],
                    references: [
                        { text: 'Microsoft Security Bulletin MS17-010', url: 'https://technet.microsoft.com/en-us/library/security/ms17-010.aspx' },
                        { text: 'CVE-2017-0144', url: 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0144' }
                    ]
                },
                assignedTo: '',
                deadline: ''
            },
            {
                id: 'CVE-2014-0160',
                name: 'Outdated OpenSSL with Heartbleed',
                host: '192.168.1.15',
                severity: 'critical',
                category: 'Network Services',
                status: 'open',
                description: 'OpenSSL contains a memory disclosure vulnerability',
                details: null
            },
            {
                id: 'CVE-2017-5638',
                name: 'Apache Struts Remote Code Execution',
                host: '192.168.1.42',
                severity: 'critical',
                category: 'Web Applications',
                status: 'open',
                description: 'Apache Struts contains a remote code execution vulnerability',
                details: null
            },
            {
                id: 'CWE-89',
                name: 'SQL Injection in Web Application',
                host: '192.168.1.38',
                severity: 'high',
                category: 'Web Applications',
                status: 'open',
                description: 'Web application is vulnerable to SQL injection attacks',
                details: null
            },
            {
                id: 'WP-OLD',
                name: 'Outdated Wordpress Version',
                host: '192.168.1.56',
                severity: 'high',
                category: 'Web Applications',
                status: 'in-progress',
                description: 'Wordpress installation is using an outdated version with known vulnerabilities',
                details: null
            },
            {
                id: 'DEFAULT-CREDS',
                name: 'Default Credentials on Admin Panel',
                host: '192.168.1.11',
                severity: 'high',
                category: 'Misconfigurations',
                status: 'open',
                description: 'Admin panel is using default credentials',
                details: null
            },
            {
                id: 'CWE-79',
                name: 'Cross-Site Scripting (XSS)',
                host: '192.168.1.38',
                severity: 'medium',
                category: 'Web Applications',
                status: 'open',
                description: 'Web application is vulnerable to cross-site scripting attacks',
                details: null
            },
            {
                id: 'SSL-EXPIRED',
                name: 'SSL Certificate Expired',
                host: '192.168.1.15',
                severity: 'medium',
                category: 'Network Services',
                status: 'fixed',
                description: 'SSL certificate has expired and needs to be renewed',
                details: null
            }
        ],
        // Current page for pagination
        currentPage: 1,
        // Items per page
        itemsPerPage: 8,
        // Current filters
        filters: {
            severity: 'All Severities',
            category: 'All Categories'
        },
        // Currently selected vulnerability
        selectedVulnerability: null
    };

    // Initialize UI components
    initMobileMenu();
    initLabNavigation(appState);
    initConfigScreen(appState);
    initVulnerabilityTable(appState);
    initFilterControls(appState);
    initPaginationControls(appState);
    initDetailViewControls(appState);
    initReportControls();
    initRemediationControls(appState);

    // Show welcome screen by default
    showScreen('welcome', appState);
});

// Initialize mobile menu
function initMobileMenu() {
    const menuBtn = document.querySelector('.mobile-menu-btn');
    const navLinks = document.querySelector('.nav-links');

    if (menuBtn) {
        menuBtn.addEventListener('click', function() {
            navLinks.classList.toggle('active');
        });
    }
}

// Initialize lab navigation
function initLabNavigation(appState) {
    // Sidebar menu links
    const labMenuLinks = document.querySelectorAll('.lab-menu-link');
    labMenuLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const screenId = this.getAttribute('data-screen');
            showScreen(screenId, appState);
        });
    });

    // Welcome screen start button
    const startBtn = document.querySelector('.start-btn');
    if (startBtn) {
        startBtn.addEventListener('click', function(e) {
            e.preventDefault();
            showScreen('scan-config', appState);
        });
    }
}

// Initialize scan configuration screen
function initConfigScreen(appState) {
    // Load saved config values
    const configInputs = document.querySelectorAll('#scan-config-screen input, #scan-config-screen select');
    configInputs.forEach(input => {
        if (input.type === 'checkbox') {
            // Handle checkboxes for vulnerability categories
            if (input.id.startsWith('check-')) {
                const category = input.id.replace('check-', '');
                if (appState.scanConfig.categories.includes(getCategoryName(category))) {
                    input.checked = true;
                }
            } else if (input.id === 'enable-auth') {
                input.checked = appState.scanConfig.authenticated;
            }
        } else if (input.type === 'text' || input.type === 'password' || input.tagName.toLowerCase() === 'select') {
            // Map field to appState property
            if (input.placeholder && input.placeholder.includes('e.g. 192.168.1.1')) {
                input.value = appState.scanConfig.targetIP;
            } else if (input.placeholder && input.placeholder.includes('e.g. example.com')) {
                input.value = appState.scanConfig.targetHostname;
            } else if (input.placeholder && input.placeholder.includes('e.g. 192.168.1.10')) {
                input.value = appState.scanConfig.excludeIPs;
            }
        }
    });

    // Save config on input change
    configInputs.forEach(input => {
        input.addEventListener('change', function() {
            saveConfig(appState);
        });
    });

    // Back button on config screen
    const backBtn = document.querySelector('#scan-config-screen .btn-secondary');
    if (backBtn) {
        backBtn.addEventListener('click', function() {
            showScreen('welcome', appState);
        });
    }

    // Start scan button
    const startScanBtn = document.querySelector('#scan-config-screen .btn-primary');
    if (startScanBtn) {
        startScanBtn.addEventListener('click', function() {
            // Save current config first
            saveConfig(appState);

            // Reset and start scan
            appState.scanProgress.status = 'running';
            appState.scanProgress.progress = 0;
            appState.scanProgress.hostsScanned = 0;
            appState.scanProgress.logs = [
                createLogEntry('Initiating scan on target network ' + appState.scanConfig.targetIP),
                createLogEntry('Performing host discovery...')
            ];

            showScreen('scan-progress', appState);
            startScan(appState);
        });
    }
}

// Get category name from checkbox id
function getCategoryName(category) {
    switch(category) {
        case 'os': return 'Operating System';
        case 'network': return 'Network Services';
        case 'web': return 'Web Applications';
        case 'db': return 'Databases';
        case 'malware': return 'Malware Detection';
        case 'config': return 'Misconfigurations';
        case 'compliance': return 'Compliance Checks';
        default: return category;
    }
}

// Save scan configuration
function saveConfig(appState) {
    // Save target information
    const targetIP = document.querySelector('#scan-config-screen input[placeholder*="192.168.1.1"]');
    const targetHostname = document.querySelector('#scan-config-screen input[placeholder*="example.com"]');
    const excludeIPs = document.querySelector('#scan-config-screen input[placeholder*="192.168.1.10"]');

    if (targetIP) appState.scanConfig.targetIP = targetIP.value;
    if (targetHostname) appState.scanConfig.targetHostname = targetHostname.value;
    if (excludeIPs) appState.scanConfig.excludeIPs = excludeIPs.value;

    // Save scan options
    const scanTypeSelect = document.querySelector('#scan-config-screen select:nth-of-type(1)');
    const scanIntensitySelect = document.querySelector('#scan-config-screen select:nth-of-type(2)');
    const portRangeSelect = document.querySelector('#scan-config-screen select:nth-of-type(3)');

    if (scanTypeSelect) appState.scanConfig.scanType = scanTypeSelect.value;
    if (scanIntensitySelect) appState.scanConfig.scanIntensity = scanIntensitySelect.value;
    if (portRangeSelect) appState.scanConfig.portRange = portRangeSelect.value;

    // Save authentication settings
    const enableAuth = document.querySelector('#enable-auth');
    const authTypeSelect = document.querySelector('#scan-config-screen select:nth-of-type(4)');
    const username = document.querySelector('#scan-config-screen input[type="text"]:nth-of-type(4)');
    const password = document.querySelector('#scan-config-screen input[type="password"]');

    if (enableAuth) appState.scanConfig.authenticated = enableAuth.checked;
    if (authTypeSelect) appState.scanConfig.authType = authTypeSelect.value;
    if (username) appState.scanConfig.username = username.value;
    if (password) appState.scanConfig.password = password.value;

    // Save vulnerability categories
    appState.scanConfig.categories = [];
    const categoryCheckboxes = document.querySelectorAll('#scan-config-screen input[type="checkbox"]');
    categoryCheckboxes.forEach(checkbox => {
        if (checkbox.id.startsWith('check-') && checkbox.checked) {
            const category = checkbox.id.replace('check-', '');
            appState.scanConfig.categories.push(getCategoryName(category));
        }
    });

    // Save schedule
    const scheduleSelect = document.querySelector('#scan-config-screen select:nth-of-type(5)');
    if (scheduleSelect) appState.scanConfig.schedule = scheduleSelect.value;

    console.log('Configuration saved:', appState.scanConfig);
}

// Create a timestamped log entry
function createLogEntry(message) {
    const now = new Date();
    const timeString = now.toTimeString().split(' ')[0];
    return `[${timeString}] ${message}`;
}

// Start the scanning process
function startScan(appState) {
    // Reset the progress
    const progressBar = document.querySelector('#scan-progress-screen .progress-bar');
    const scanStatus = document.querySelector('#scan-progress-screen .scan-status');
    const logContainer = document.querySelector('#scan-progress-screen .activity-log');

    if (progressBar) {
        progressBar.style.width = '0%';
        progressBar.textContent = '0%';
    }

    if (scanStatus) {
        scanStatus.textContent = `Scanning target ${appState.scanConfig.targetIP} - 0 of ${appState.scanProgress.totalHosts} hosts completed`;
    }

    if (logContainer) {
        // Clear existing logs
        logContainer.innerHTML = '';

        // Add initial logs
        appState.scanProgress.logs.forEach(log => {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = log;
            logContainer.appendChild(logEntry);
        });
    }

    // Generate more logs and update progress
    simulateScan(appState);
}

// Simulate the scanning process
function simulateScan(appState) {
    const progressBar = document.querySelector('#scan-progress-screen .progress-bar');
    const scanStatus = document.querySelector('#scan-progress-screen .scan-status');
    const logContainer = document.querySelector('#scan-progress-screen .activity-log');
    const pauseBtn = document.querySelector('#scan-progress-screen .btn-secondary');

    // Create a realistic scan simulation that progresses over time
    let currentHost = 1;
    let progress = 0;

    // More realistic scan simulation with varying time between log entries
    const scanInterval = setInterval(() => {
        // Check if scan is paused
        if (appState.scanProgress.status !== 'running') {
            return;
        }

        // Update host count
        currentHost += Math.floor(Math.random() * 3) + 1; // Scan 1-3 hosts at a time
        if (currentHost > appState.scanProgress.totalHosts) {
            currentHost = appState.scanProgress.totalHosts;
        }

        // Update progress percentage
        progress = Math.round((currentHost / appState.scanProgress.totalHosts) * 100);
        if (progress > 100) progress = 100;

        appState.scanProgress.hostsScanned = currentHost;
        appState.scanProgress.progress = progress;

        // Update UI
        if (progressBar) {
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `${progress}%`;
        }

        if (scanStatus) {
            scanStatus.textContent = `Scanning target ${appState.scanConfig.targetIP} - ${currentHost} of ${appState.scanProgress.totalHosts} hosts completed`;
        }

        // Generate realistic log entry
        const currentIP = `192.168.1.${currentHost}`;
        const logEntries = [];

        // Start scanning message
        logEntries.push(createLogEntry(`Scanning host ${currentIP}...`));

        // Random number of open ports
        const numPorts = Math.floor(Math.random() * 8) + 1;
        logEntries.push(createLogEntry(`Found ${numPorts} open ports on host ${currentIP}`));

        // Potential services
        const services = ['HTTP', 'HTTPS', 'SSH', 'FTP', 'SMB', 'DNS', 'SMTP', 'RDP', 'MySQL', 'PostgreSQL'];
        for (let i = 0; i < Math.min(3, numPorts); i++) {
            const service = services[Math.floor(Math.random() * services.length)];
            const port = getPortForService(service);
            logEntries.push(createLogEntry(`Identified service: ${service} on port ${port}`));
        }

        // Running vulnerability checks
        logEntries.push(createLogEntry(`Running vulnerability checks on host ${currentIP}`));

        // Random chance to find vulnerabilities
        if (Math.random() < 0.4) {
            // Potential vulnerabilities
            const vulnOptions = [
                'Outdated Apache Version 2.4.34',
                'SSL Certificate Expired',
                'Default SSH Keys (CVE-2023-2650)',
                'OpenSSH < 7.7 Username Enumeration (CVE-2018-15473)',
                'Missing Security Headers',
                'Directory Listing Enabled',
                'Outdated PHP Version (7.2.34)',
                'Unpatched Windows OS (KB4562562)',
                'Default SNMP Community Strings'
            ];

            // Add 1-2 vulnerabilities
            const numVulns = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < numVulns; i++) {
                const vuln = vulnOptions[Math.floor(Math.random() * vulnOptions.length)];

                // Small chance to find a critical vulnerability
                if (Math.random() < 0.1) {
                    const criticalVulns = [
                        'Critical vulnerability: SMB v1 Enabled (MS17-010)',
                        'Critical vulnerability: Log4Shell (CVE-2021-44228)',
                        'Critical vulnerability: BlueKeep (CVE-2019-0708)'
                    ];
                    logEntries.push(createLogEntry(`Found ${criticalVulns[Math.floor(Math.random() * criticalVulns.length)]}`));
                } else {
                    logEntries.push(createLogEntry(`Found vulnerability: ${vuln}`));
                }
            }
        }

        // Moving to next host
        logEntries.push(createLogEntry(`Moving to next host...`));

        // Add log entries to UI with a small delay between each
        let entryIndex = 0;
        const addLogEntry = () => {
            if (entryIndex < logEntries.length) {
                // Add to app state
                appState.scanProgress.logs.push(logEntries[entryIndex]);

                // Add to UI
                if (logContainer) {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.textContent = logEntries[entryIndex];
                    logContainer.appendChild(logEntry);

                    // Auto-scroll to bottom
                    logContainer.scrollTop = logContainer.scrollHeight;
                }

                entryIndex++;
                setTimeout(addLogEntry, 300 + Math.random() * 200);
            }
        };

        addLogEntry();

        // Stop when complete
        if (currentHost >= appState.scanProgress.totalHosts) {
            clearInterval(scanInterval);
            appState.scanProgress.status = 'completed';

            // Add final log entry
            const completionLog = createLogEntry(`Scan completed. Found 49 vulnerabilities across ${appState.scanProgress.totalHosts} hosts.`);
            appState.scanProgress.logs.push(completionLog);

            if (logContainer) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.textContent = completionLog;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            // Update pause button
            if (pauseBtn) {
                pauseBtn.textContent = 'Scan Complete';
                pauseBtn.disabled = true;
            }
        }
    }, 4000 + Math.random() * 2000); // Random interval between 4-6 seconds

    // Handle pause button
    if (pauseBtn) {
        pauseBtn.addEventListener('click', function() {
            if (appState.scanProgress.status === 'running') {
                appState.scanProgress.status = 'paused';
                this.textContent = 'Resume Scan';

                // Add pause log entry
                const pauseLog = createLogEntry('Scan paused by user');
                appState.scanProgress.logs.push(pauseLog);

                if (logContainer) {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.textContent = pauseLog;
                    logContainer.appendChild(logEntry);
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
            } else if (appState.scanProgress.status === 'paused') {
                appState.scanProgress.status = 'running';
                this.textContent = 'Pause Scan';

                // Add resume log entry
                const resumeLog = createLogEntry('Scan resumed');
                appState.scanProgress.logs.push(resumeLog);

                if (logContainer) {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.textContent = resumeLog;
                    logContainer.appendChild(logEntry);
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
            }
        });
    }

    // Handle view results button
    const viewResultsBtn = document.querySelector('#scan-progress-screen .btn-primary');
    if (viewResultsBtn) {
        viewResultsBtn.addEventListener('click', function() {
            // Even if scan is still running, we can view current results
            showScreen('scan-results', appState);
        });
    }
}

// Get common port for a service
function getPortForService(service) {
    const portMap = {
        'HTTP': 80,
        'HTTPS': 443,
        'SSH': 22,
        'FTP': 21,
        'SMB': 445,
        'DNS': 53,
        'SMTP': 25,
        'RDP': 3389,
        'MySQL': 3306,
        'PostgreSQL': 5432
    };

    return portMap[service] || Math.floor(Math.random() * 10000) + 1000;
}

// Initialize vulnerability table
function initVulnerabilityTable(appState) {
    // Populate vulnerability table with data
    updateVulnerabilityTable(appState);

    // Add event listeners for table rows
    setupVulnerabilityTableListeners(appState);
}

// Update vulnerability table based on current filters and pagination
function updateVulnerabilityTable(appState) {
    const tableBody = document.querySelector('.vulnerabilities-table tbody');
    if (!tableBody) return;

    // Clear existing rows
    tableBody.innerHTML = '';

    // Get filtered vulnerabilities
    const filteredVulns = filterVulnerabilities(appState);

    // Calculate pagination
    const startIndex = (appState.currentPage - 1) * appState.itemsPerPage;
    const endIndex = Math.min(startIndex + appState.itemsPerPage, filteredVulns.length);
    const pageVulns = filteredVulns.slice(startIndex, endIndex);

    // Create table rows
    pageVulns.forEach(vuln => {
        const row = document.createElement('tr');
        row.setAttribute('data-vuln-id', vuln.id);

        // Create content
        row.innerHTML = `
            <td>
                <div style="font-weight: 500;">${vuln.name}</div>
                <div class="vulnerability-id">${vuln.id}</div>
            </td>
            <td>${vuln.host}</td>
            <td><span class="severity-badge ${vuln.severity}">${capitalizeFirst(vuln.severity)}</span></td>
            <td>${vuln.category}</td>
            <td><span class="status-badge ${vuln.status}">${formatStatus(vuln.status)}</span></td>
        `;

        // Add click handler
        row.addEventListener('click', function() {
            appState.selectedVulnerability = vuln;
            showVulnerabilityDetail(appState);
        });

        tableBody.appendChild(row);
    });

    // Update pagination
    updatePagination(appState, filteredVulns.length);
}

// Filter vulnerabilities based on current filters
function filterVulnerabilities(appState) {
    let filtered = [...appState.vulnerabilities];

    // Filter by severity
    if (appState.filters.severity !== 'All Severities') {
        if (appState.filters.severity === 'Critical Only') {
            filtered = filtered.filter(v => v.severity === 'critical');
        } else if (appState.filters.severity === 'High & Critical') {
            filtered = filtered.filter(v => v.severity === 'critical' || v.severity === 'high');
        } else if (appState.filters.severity === 'Medium & Above') {
            filtered = filtered.filter(v => v.severity !== 'low');
        }
    }

    // Filter by category
    if (appState.filters.category !== 'All Categories') {
        filtered = filtered.filter(v => v.category === appState.filters.category);
    }

    return filtered;
}

// Update pagination controls
function updatePagination(appState, totalItems) {
    const paginationContainer = document.querySelector('.pagination');
    if (!paginationContainer) return;

    // Clear existing buttons
    paginationContainer.innerHTML = '';

    // Calculate total pages
    const totalPages = Math.ceil(totalItems / appState.itemsPerPage) || 1;

    // Prev button
    const prevBtn = document.createElement('div');
    prevBtn.className = 'page-btn';
    prevBtn.innerHTML = '<i class="fas fa-chevron-left"></i>';
    prevBtn.addEventListener('click', function() {
        if (appState.currentPage > 1) {
            appState.currentPage--;
            updateVulnerabilityTable(appState);
        }
    });
    paginationContainer.appendChild(prevBtn);

    // Page buttons
    for (let i = 1; i <= totalPages; i++) {
        const pageBtn = document.createElement('div');
        pageBtn.className = 'page-btn' + (i === appState.currentPage ? ' active' : '');
        pageBtn.textContent = i;
        pageBtn.addEventListener('click', function() {
            appState.currentPage = i;
            updateVulnerabilityTable(appState);
        });
        paginationContainer.appendChild(pageBtn);
    }

    // Next button
    const nextBtn = document.createElement('div');
    nextBtn.className = 'page-btn';
    nextBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
    nextBtn.addEventListener('click', function() {
        if (appState.currentPage < totalPages) {
            appState.currentPage++;
            updateVulnerabilityTable(appState);
        }
    });
    paginationContainer.appendChild(nextBtn);
}

// Initialize filter controls
function initFilterControls(appState) {
    const filterSelects = document.querySelectorAll('.filter-select');
    filterSelects.forEach((select, index) => {
        select.addEventListener('change', function() {
            // Update filter in app state
            if (index === 0) { // Severity filter
                appState.filters.severity = this.value;
            } else if (index === 1) { // Category filter
                appState.filters.category = this.value;
            }

            // Reset to first page
            appState.currentPage = 1;

            // Update table
            updateVulnerabilityTable(appState);
        });
    });

    // Export report button
    const exportReportBtn = document.querySelector('#scan-results-screen .btn-primary');
    if (exportReportBtn) {
        exportReportBtn.addEventListener('click', function() {
            const filteredVulns = filterVulnerabilities(appState);
            alert(`Exporting report with ${filteredVulns.length} vulnerabilities. This would download a PDF in a real implementation.`);
        });
    }
}

// Setup vulnerability table row listeners
function setupVulnerabilityTableListeners(appState) {
    const vulnerabilityRows = document.querySelectorAll('.vulnerabilities-table tbody tr');
    vulnerabilityRows.forEach(row => {
        const vulnId = row.getAttribute('data-vuln-id');
        if (vulnId) {
            // Find the vulnerability
            const vuln = appState.vulnerabilities.find(v => v.id === vulnId);

            row.addEventListener('click', function() {
                appState.selectedVulnerability = vuln;
                showVulnerabilityDetail(appState);
            });
        }
    });
}

// Initialize pagination controls
function initPaginationControls(appState) {
    // Initial pagination
    updatePagination(appState, appState.vulnerabilities.length);
}

// Initialize vulnerability detail controls
function initVulnerabilityDetailControls(appState) {
    // Back to results button
    document.addEventListener('click', function(e) {
        if (e.target && e.target.matches('#vulnerability-detail .btn-secondary:last-child')) {
            hideVulnerabilityDetail();
        }
    });

    // Mark as In Progress button
    document.addEventListener('click', function(e) {
        if (e.target && e.target.matches('#vulnerability-detail .btn-primary')) {
            if (appState.selectedVulnerability) {
                // Update status in app state
                appState.selectedVulnerability.status = 'in-progress';

                // Find the vulnerability in the full list and update it
                const vulnIndex = appState.vulnerabilities.findIndex(v => v.id === appState.selectedVulnerability.id);
                if (vulnIndex !== -1) {
                    appState.vulnerabilities[vulnIndex].status = 'in-progress';
                }

                // Update the detail view
                const statusBadge = document.querySelector('#vulnerability-detail .detail-meta-item:nth-child(4)');
                if (statusBadge) {
                    statusBadge.innerHTML = '<i class="fas fa-exclamation-circle"></i> Status: In Progress';
                }

                // Show success message
                alert(`Status for ${appState.selectedVulnerability.name} updated to In Progress`);

                // Update the table
                updateVulnerabilityTable(appState);
            }
        }
    });

    // Assign ticket button
    document.addEventListener('click', function(e) {
        if (e.target && e.target.matches('#vulnerability-detail .detail-actions .btn-secondary:nth-child(2)')) {
            if (appState.selectedVulnerability) {
                const assignee = prompt('Enter the name or team to assign this vulnerability to:', 'Security Team');
                if (assignee) {
                    // Update in app state
                    appState.selectedVulnerability.assignedTo = assignee;

                    // Update in full list
                    const vulnIndex = appState.vulnerabilities.findIndex(v => v.id === appState.selectedVulnerability.id);
                    if (vulnIndex !== -1) {
                        appState.vulnerabilities[vulnIndex].assignedTo = assignee;
                    }

                    alert(`Vulnerability assigned to: ${assignee}`);
                }
            }
        }
    });

    // Set deadline button
    document.addEventListener('click', function(e) {
        if (e.target && e.target.matches('#vulnerability-detail .detail-actions .btn-secondary:nth-child(3)')) {
            if (appState.selectedVulnerability) {
                const deadline = prompt('Enter the deadline for remediation (YYYY-MM-DD):', getCurrentDatePlus7Days());
                if (deadline) {
                    // Update in app state
                    appState.selectedVulnerability.deadline = deadline;

                    // Update in full list
                    const vulnIndex = appState.vulnerabilities.findIndex(v => v.id === appState.selectedVulnerability.id);
                    if (vulnIndex !== -1) {
                        appState.vulnerabilities[vulnIndex].deadline = deadline;
                    }

                    alert(`Remediation deadline set to: ${deadline}`);
                }
            }
        }
    });
}

// Get current date plus 7 days in YYYY-MM-DD format
function getCurrentDatePlus7Days() {
    const date = new Date();
    date.setDate(date.getDate() + 7);

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    return `${year}-${month}-${day}`;
}

// Initialize report controls
function initReportControls() {
    const reportTypeButtons = document.querySelectorAll('#reports-screen .btn-secondary');
    reportTypeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const reportType = this.textContent.trim();
            generateReport(reportType);
        });
    });
}

// Generate a report (simulation)
function generateReport(reportType) {
    alert(`Generating ${reportType}... In a real implementation, this would create and download a detailed PDF report.`);
}

// Initialize remediation controls
function initRemediationControls(appState) {
    // Update remediation progress
    updateRemediationProgress(appState);

    // Set up row click events for remediation table
    const remediationTableRows = document.querySelectorAll('#remediation-screen .vulnerabilities-table tbody tr');
    remediationTableRows.forEach(row => {
        row.addEventListener('click', function() {
            const vulnName = this.querySelector('td:first-child div:first-child').textContent.trim();

            // Find vulnerability in app state
            const vuln = appState.vulnerabilities.find(v => v.name === vulnName);
            if (vuln) {
                appState.selectedVulnerability = vuln;
                showVulnerabilityDetail(appState);
            }
        });
    });
}

// Update remediation progress display
function updateRemediationProgress(appState) {
    const progressBar = document.querySelector('#remediation-screen .progress-bar');
    const progressText = document.querySelector('#remediation-screen p');

    if (progressBar && progressText) {
        // Count fixed vulnerabilities
        const fixedCount = appState.vulnerabilities.filter(v => v.status === 'fixed').length;
        const totalCount = appState.vulnerabilities.length;
        const percentage = Math.round((fixedCount / totalCount) * 100);

        // Update UI
        progressBar.style.width = `${percentage}%`;
        progressBar.textContent = `${percentage}%`;
        progressText.textContent = `${fixedCount} of ${totalCount} vulnerabilities remediated`;
    }

    // Update remediation table if it exists
    const tableBody = document.querySelector('#remediation-screen .vulnerabilities-table tbody');
    if (tableBody) {
        tableBody.innerHTML = '';

        // Add rows for vulnerabilities that are in-progress or fixed
        const remediationVulns = appState.vulnerabilities.filter(v => v.status === 'in-progress' || v.status === 'fixed');

        remediationVulns.forEach(vuln => {
            const row = document.createElement('tr');

            row.innerHTML = `
                <td>
                    <div style="font-weight: 500;">${vuln.name}</div>
                    <div class="vulnerability-id">${vuln.id}</div>
                </td>
                <td><span class="severity-badge ${vuln.severity}">${capitalizeFirst(vuln.severity)}</span></td>
                <td><span class="status-badge ${vuln.status}">${formatStatus(vuln.status)}</span></td>
                <td>${vuln.assignedTo || 'Unassigned'}</td>
                <td>${vuln.deadline || 'No deadline'}</td>
            `;

            tableBody.appendChild(row);
        });
    }
}

// Helper function to capitalize first letter
function capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// Helper function to format status
function formatStatus(status) {
    if (status === 'in-progress') return 'In Progress';
    return capitalizeFirst(status);
}

// Show a specific screen
function showScreen(screenId, appState) {
    // Save current screen
    appState.currentScreen = screenId;

    // Hide all screens
    const screens = document.querySelectorAll('.lab-screen');
    screens.forEach(screen => {
        screen.style.display = 'none';
    });

    // Show the selected screen
    const selectedScreen = document.getElementById(screenId + '-screen');
    if (selectedScreen) {
        selectedScreen.style.display = 'block';
    }

    // Update sidebar menu
    updateSidebarMenu(screenId);

    // Special handling for each screen
    if (screenId === 'scan-results') {
        // Update vulnerability table
        updateVulnerabilityTable(appState);

        // Update summary cards
        updateSummaryCards(appState);
    } else if (screenId === 'remediation') {
        // Update remediation progress
        updateRemediationProgress(appState);
    }

    // Scroll to top
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
}

// Update summary cards in results screen
function updateSummaryCards(appState) {
    const criticalCard = document.querySelector('.summary-value.critical');
    const highCard = document.querySelector('.summary-value.high');
    const mediumCard = document.querySelector('.summary-value.medium');
    const lowCard = document.querySelector('.summary-value.low');

    if (criticalCard) {
        criticalCard.textContent = appState.vulnerabilities.filter(v => v.severity === 'critical').length;
    }

    if (highCard) {
        highCard.textContent = appState.vulnerabilities.filter(v => v.severity === 'high').length;
    }

    if (mediumCard) {
        mediumCard.textContent = appState.vulnerabilities.filter(v => v.severity === 'medium').length;
    }

    if (lowCard) {
        lowCard.textContent = appState.vulnerabilities.filter(v => v.severity === 'low').length;
    }
}

// Update sidebar menu
function updateSidebarMenu(activeScreenId) {
    const menuLinks = document.querySelectorAll('.lab-menu-link');
    menuLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('data-screen') === activeScreenId) {
            link.classList.add('active');
        }
    });
}

// Show vulnerability detail
function showVulnerabilityDetail(appState) {
    const detailView = document.getElementById('vulnerability-detail');
    if (!detailView || !appState.selectedVulnerability) return;

    // Get the vulnerability
    const vuln = appState.selectedVulnerability;

    // Update detail view with vulnerability info
    const detailTitle = document.querySelector('.detail-title');
    const detailId = document.querySelector('.detail-id');
    const severityBadge = document.querySelector('#vulnerability-detail .severity-badge');

    if (detailTitle) detailTitle.textContent = vuln.name;
    if (detailId) detailId.textContent = vuln.id;
    if (severityBadge) {
        severityBadge.className = `severity-badge ${vuln.severity}`;
        severityBadge.textContent = capitalizeFirst(vuln.severity);
    }

    // Update metadata
    const metaItems = document.querySelectorAll('.detail-meta-item');
    if (metaItems && metaItems.length >= 4) {
        // Host
        metaItems[0].innerHTML = `<i class="fas fa-server"></i> Host: ${vuln.host}`;

        // Category
        metaItems[1].innerHTML = `<i class="fas fa-tag"></i> Category: ${vuln.category}`;

        // Discovery date
        const discoveryDate = vuln.details && vuln.details.discovered ? vuln.details.discovered : 'May 1, 2025';
        metaItems[2].innerHTML = `<i class="fas fa-calendar-alt"></i> Discovered: ${discoveryDate}`;

        // Status
        metaItems[3].innerHTML = `<i class="fas fa-exclamation-circle"></i> Status: ${formatStatus(vuln.status)}`;
    }

    // Update description
    const descriptionContent = document.querySelector('.detail-section:nth-child(5) .detail-section-content');
    if (descriptionContent) {
        descriptionContent.innerHTML = `<p>${vuln.description}</p>`;

        // Add additional paragraph if available
        if (vuln.details && vuln.details.description) {
            descriptionContent.innerHTML += `<p>${vuln.details.description}</p>`;
        }
    }

    // Show the detail view
    detailView.style.display = 'block';

    // Scroll to the detail view
    detailView.scrollIntoView({
        behavior: 'smooth',
        block: 'start'
    });
}

// Hide vulnerability detail
function hideVulnerabilityDetail() {
    const detailView = document.getElementById('vulnerability-detail');
    if (detailView) {
        detailView.style.display = 'none';
    }
}